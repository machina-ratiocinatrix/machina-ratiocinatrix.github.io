<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=b1124390a122e861b4918632b23394369790a5d0">
    <title>Machina Ratiocinatrix</title>
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->
    <!-- Setup Google Analytics -->
    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->
    <!-- end custom head snippets -->
</head>
  <body>
    <div class="container-md px-3 my-5 markdown-body">
        <h1><a href="https://machina-ratiocinatrix.github.io/">Machina Ratiocinatrix</a></h1>
        <script>
            /**
             * Transforms platoHtml format to CMJ (Chat Messages JSON) format.
             * @param {string} htmlText - The platoHtml formatted string.
             * @returns {string} - JSON stringified array of message objects.
             */
            function platoHtmlToCmj(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }

              const messages = [];
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              });

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }

            /**
             * Transforms platoHtml format to platoText format.
             * @param {string} htmlText - The platoHtml formatted string.
             * @returns {string} - The platoText formatted string.
             */
            function platoHtmlToPlatoText(htmlText) {
              if (typeof htmlText !== 'string') { // Allow empty string
                throw new Error('Invalid input: htmlText must be a string');
              }
              if (!htmlText.trim()) {
                return '';
              }

              let result = '';
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return;

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();
                result += `${speaker}: ${utterance}\n\n`;
              });

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to platoHtml format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - The platoHtml formatted string.
             */
            function platoTextToPlatoHtml(platoText) {
              if (typeof platoText !== 'string') { // Allow empty string
                throw new Error('Invalid input: platoText must be a string');
              }
              // If platoText is an empty string or only whitespace, return an empty string.
              // The display logic will handle showing the file picker or placeholder.
              if (!platoText.trim()) {
                return '';
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              let result = '';
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim().replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML characters
                result += `<p class="dialogue"><span class="speaker">${speaker}</span> ${utterance}</p>\n`;
              }

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to CMJ (Chat Messages JSON) format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - JSON stringified array of message objects.
             */
            function platoTextToCmj(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              const messages = [];
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              }

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }
        </script>

        <!-- Initial dialogue content (will be hidden by script if localStorage is used) -->
        <p class="dialogue"><span class="speaker">Socrates</span>What is justice, my friend?</p>
        <!-- Commented out other examples for brevity -->
        <!-- <p class="dialogue"><span class="speaker">Thrasymachus</span>Justice is the advantage of the stronger.</p> -->

        <script>
        document.addEventListener('DOMContentLoaded', () => {
            const contentContainer = document.querySelector('.container-md.markdown-body');
            if (!contentContainer) {
                console.error('Main content container (.container-md.markdown-body) not found.');
                return;
            }
            const h1Element = contentContainer.querySelector('h1');
            if (!h1Element) {
                console.error('H1 element not found. UI elements might be misplaced.');
            }

            // Capture HTML from original static <p class="dialogue"> elements and then hide them.
            // These elements are not moved, respecting their original structure for other potential uses,
            // but are hidden to cede display control to the dynamic dialogueWrapper.
            const originalStaticDialogueElements = Array.from(contentContainer.querySelectorAll('p.dialogue'));
            let initialHtmlFromStatic = '';
            originalStaticDialogueElements.forEach(p => {
                initialHtmlFromStatic += p.outerHTML; // Capture their HTML content
                p.style.display = 'none';          // Hide the original static element
            });

            // 1. Create a wrapper for the dialogue content (will be populated by updateDisplayState)
            const dialogueWrapper = document.createElement('div');
            dialogueWrapper.id = 'dialogue-content-wrapper';

            // 2. Create the textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'form-control';
            textarea.style.width = '100%';
            textarea.style.minHeight = '830px';
            textarea.style.display = 'none'; // Initially hidden
            textarea.style.setProperty('border', '1px solid lightgrey', 'important');
            textarea.style.padding = '10px';

            // 3. Create container and button for file picking
            const filePickerContainer = document.createElement('div');
            filePickerContainer.id = 'file-picker-container';
            filePickerContainer.style.width = '100%';
            filePickerContainer.style.minHeight = '830px'; // Match textarea height
            filePickerContainer.style.display = 'flex'; // Changed from 'none' to 'flex' for centering
            filePickerContainer.style.justifyContent = 'center';
            filePickerContainer.style.alignItems = 'center';
            filePickerContainer.style.padding = '20px';
            filePickerContainer.style.display = 'none'; // Initially hidden, updateDisplayState will show it

            const chooseFileButton = document.createElement('button');
            chooseFileButton.id = 'chooseFileButton';
            chooseFileButton.className = 'btn btn-primary'; // GitHub Primer style
            chooseFileButton.textContent = 'Choose File to Load Dialogue';
            chooseFileButton.style.padding = '10px 20px'; // Make button larger
            chooseFileButton.style.fontSize = '1.0rem';
            filePickerContainer.appendChild(chooseFileButton);

            // 4. Insert dynamic elements into the DOM (after H1 or fallback)
            if (h1Element) {
                h1Element.after(dialogueWrapper, textarea, filePickerContainer);
            } else {
                contentContainer.prepend(dialogueWrapper, textarea, filePickerContainer); // Fallback
            }

            // 5. Initialize localStorage:
            // If 'platoText' is null, try to populate from static HTML. Otherwise, use existing.
            let platoTextForInit = localStorage.getItem('platoText');
            if (platoTextForInit === null) {
                if (initialHtmlFromStatic.trim() !== '') {
                    try {
                        platoTextForInit = platoHtmlToPlatoText(initialHtmlFromStatic);
                    } catch (e) {
                        console.error("Error converting initial static HTML to Plato text:", e);
                        platoTextForInit = ''; // Fallback to empty string on error
                    }
                } else {
                    platoTextForInit = ''; // No static content, initialize as empty
                }
                localStorage.setItem('platoText', platoTextForInit);
            }
            // Now, localStorage.getItem('platoText') is guaranteed to be a string (possibly empty).

            // 6. Function to update display based on localStorage content
            function updateDisplayState() {
                const currentPlatoText = localStorage.getItem('platoText');
                if (currentPlatoText && currentPlatoText.trim() !== '') {
                    try {
                        dialogueWrapper.innerHTML = platoTextToPlatoHtml(currentPlatoText);
                    } catch (e) {
                        console.error("Error rendering Plato text to HTML:", e);
                        dialogueWrapper.innerHTML = "<p class='dialogue-error'>Error loading content. Please try editing or loading a new file.</p>";
                    }
                    dialogueWrapper.style.display = 'block';
                    textarea.style.display = 'none';
                    filePickerContainer.style.display = 'none';
                } else {
                    // No valid content, show file picker
                    dialogueWrapper.style.display = 'none';
                    textarea.style.display = 'none';
                    filePickerContainer.style.display = 'flex'; // Use flex to enable centering
                    dialogueWrapper.innerHTML = ''; // Clear any old content
                    textarea.value = ''; // Clear textarea
                }
            }

            // Initial display update
            updateDisplayState();

            // 7. Event listener for "Choose File" button
            chooseFileButton.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Text Files',
                            accept: {
                                'text/plain': ['.txt', '.md', '.text'],
                            }
                        }]
                    });
                    const file = await fileHandle.getFile();
                    const fileContent = await file.text();

                    localStorage.setItem('platoText', fileContent);
                    // No need to set textarea.value here, updateDisplayState will handle if we switch to editor
                    // OR, if we want to go directly to editor:
                    textarea.value = fileContent;
                    dialogueWrapper.style.display = 'none';
                    filePickerContainer.style.display = 'none';
                    textarea.style.display = 'block';
                    textarea.focus();
                    // If not going directly to editor, just call updateDisplayState()
                    // updateDisplayState();
                } catch (err) {
                    if (err.name !== 'AbortError') { // User cancelled picker
                        console.error('Error opening file:', err);
                        alert(`Error opening file: ${err.message}`);
                    }
                }
            });

            // 8. Event listener to switch to edit mode when dialogue content is clicked
            dialogueWrapper.addEventListener('click', () => {
                try {
                    // Read directly from localStorage to ensure consistency,
                    // as dialogueWrapper.innerHTML might have formatting quirks.
                    const plainText = localStorage.getItem('platoText') || '';
                    // Or, if conversion from current HTML is preferred:
                    // const plainText = platoHtmlToPlatoText(dialogueWrapper.innerHTML);
                    textarea.value = plainText;
                    dialogueWrapper.style.display = 'none';
                    textarea.style.display = 'block';
                    filePickerContainer.style.display = 'none';
                    textarea.focus();
                } catch (e) {
                    console.error("Error converting HTML to Plato text for editing:", e);
                    alert("Could not switch to edit mode due to a content error.");
                }
            });

            // 9. Event listener for saving (Ctrl+Enter) in the textarea
            textarea.addEventListener('keydown', (event) => {
                if (event.ctrlKey && !event.shiftKey && event.key === 'Enter') { // Changed from Shift to Enter as per original request context
                    event.preventDefault();
                    const newText = textarea.value;
                    localStorage.setItem('platoText', newText);
                    updateDisplayState(); // Update display, which will show dialogue or button
                }
            });

            // 10. Event listener for saving to file (Ctrl+Shift+Enter) - Always "Save As"
            textarea.addEventListener('keydown', async (event) => {
                if (event.ctrlKey && event.shiftKey && event.key === 'Enter') {
                    event.preventDefault();
                    const textToSave = textarea.value;

                    try {
                        // Always prompt "Save As"
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: 'dialogue.txt', // You can customize the suggested name
                            types: [{
                                description: 'Text Files',
                                accept: {
                                    'text/plain': ['.txt', '.md', '.text'],
                                },
                            }],
                        });

                        // Create a FileSystemWritableFileStream to write to.
                        const writable = await fileHandle.createWritable();

                        // Write the contents of the file to the stream.
                        await writable.write(textToSave);

                        // Close the file and write the contents to disk.
                        await writable.close();

                        // If file save was successful, then update localStorage
                        localStorage.setItem('platoText', textToSave);
                        updateDisplayState(); // Refresh the view

                        // Optional: alert('Dialogue saved to file!');

                    } catch (err) {
                        // Handle errors, e.g., if the user cancels the save dialog
                        if (err.name !== 'AbortError') {
                            console.error('Error saving file:', err);
                            alert(`Could not save file: ${err.message}`);
                        }
                    }
                }
            });

            // 11. Event listener for auto-saving to localStorage on input
            textarea.addEventListener('input', () => {
                localStorage.setItem('platoText', textarea.value);
            });
        });
        </script>
    </div>
    <script>
        document.addEventListener('keydown', function(event) {
            // Check for Alt + Shift key combination
            if (event.altKey && event.shiftKey) {
                event.preventDefault(); // Prevent any default browser action for Alt+Shift
                console.log('Alt+Shift pressed Launching LLM worker...');
                try {
                    const llmWorker = new Worker('assets/js/worker.js');
                    llmWorker.onmessage = function(e) {
                        console.log('Main thread: Message received from worker:', e.data);
                        if (e.data.type === 'success') {
                            console.log('Worker task successful. LLM Response:', e.data.data);
                            // For now, just alerting. Later, you'll process this data.
                            alert('Worker finished successfully! Check the console for the LLM response.');
                            // TODO: Implement next steps:
                            // 1. Append LLM response (e.data.data.choices[0].message.content) to CMJ.
                            // 2. Transform CMJ to platoText.
                            // 3. Save platoText to local storage.
                            // 4. Transform platoText to platoHtml.
                            // 5. Display platoHtml on page.
                        } else if (e.data.type === 'error') {
                            console.error('Main thread: Error message from worker:', e.data.error);
                            alert('Worker reported an error: ' + e.data.error);
                        }
                    };

                    llmWorker.onerror = function(error) {
                        console.error('Main thread: An error occurred with the worker script:', error.message, error);
                        alert('Failed to initialize or run worker: ' + error.message);
                    };

                    // Send parameters to the worker.
                    // For this initial stage, we send an empty object. The worker.js
                    // has default parameters it will use for the API call.
                    // In later stages, you will construct and send the actual
                    // CMJ formatted messages here.
                    const userQueryParameters = {};
                    llmWorker.postMessage(userQueryParameters);

                    console.log('Main thread: Worker launched and an empty message sent (worker will use its defaults).');

                } catch (e) {
                    console.error('Main thread: Failed to create or communicate with the worker:', e);
                    alert('Error initializing worker: ' + e.message);
                }
            }
        });
  </script>
  </body>
</html>

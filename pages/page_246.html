<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=b1124390a122e861b4918632b23394369790a5d0">
    <title>MACHINA RATIOCINATRIX</title>
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->
    <!-- Setup Google Analytics -->
    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->
    <!-- end custom head snippets -->
</head>
  <body>
    <div class="container-md px-3 my-5 markdown-body">
        <h1><a href="https://machina-ratiocinatrix.github.io/">Machina Ratiocinatrix</a></h1>
        <script>
            /**
 * Transforms platoHtml format to CMJ (Chat Messages JSON) format.
 * @param {string} htmlText - The platoHtml formatted string.
 * @returns {string} - JSON stringified array of message objects.
 */
            function platoHtmlToCmj(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }

              const messages = [];
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                // Extract utterance by removing speaker span and trimming
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              });

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }

            /**
             * Transforms platoHtml format to platoText format.
             * @param {string} htmlText - The platoHtml formatted string.
             * @returns {string} - The platoText formatted string.
             */
            function platoHtmlToPlatoText(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }
              if (!htmlText.trim()) { // Handles empty string or string with only whitespace
                return '';
              }

              let result = '';
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();
                result += `${speaker}: ${utterance}\n\n`;
              });

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to platoHtml format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - The platoHtml formatted string.
             */
            function platoTextToPlatoHtml(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }
              if (!platoText.trim()) { // Handles empty string or string with only whitespace
                return 'start the dialogue here';
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              let result = '';
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim().replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML characters
                result += `<p class="dialogue"><span class="speaker">${speaker}</span> ${utterance}</p>\n`;
              }

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to CMJ (Chat Messages JSON) format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - JSON stringified array of message objects.
             */
            function platoTextToCmj(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              const messages = [];
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              }

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }
        </script>
        <p class="dialogue"><span class="speaker">Socrates</span>What is justice, my friend?</p>
<!--        <p class="dialogue"><span class="speaker">Thrasymachus</span>Justice is the advantage of the stronger.</p>-->
<!--        <p class="dialogue"><span class="speaker">Machina Ratiocinatrix</span>I think you are oversimplifying it, Thrasymachus, trying to reduce a truely multi-dimensional problem to a single dimension.</p>-->
<!--        <p class="dialogue"><span class="speaker">Socrates</span>Can you explain what you mean, Machina?</p>-->
        <script>
        document.addEventListener('DOMContentLoaded', () => {
            const contentContainer = document.querySelector('.container-md.markdown-body');
            if (!contentContainer) {
                console.error('Main content container (.container-md.markdown-body) not found.');
                return;
            }
            const h1Element = contentContainer.querySelector('h1');
            if (!h1Element) {
                console.error('H1 element not found within content container. The editor might not be placed correctly.');
                // If H1 is critical for placement, you might want to return or handle this case.
            }
            // 1. Create a wrapper for the dialogue content
            const dialogueWrapper = document.createElement('div');
            dialogueWrapper.id = 'dialogue-content-wrapper';
            // 2. Move existing <p class="dialogue"> elements into this new wrapper
            // This also removes them from their original position in contentContainer.
            const existingDialogues = Array.from(contentContainer.querySelectorAll('p.dialogue'));
            existingDialogues.forEach(p => {
                dialogueWrapper.appendChild(p);
            });
            // 3. Create the textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'form-control'; // Apply GitHub Primer styling
            textarea.style.width = '100%';
            textarea.style.minHeight = '700px';
            textarea.style.display = 'none'; // Initially hidden
            textarea.style.borderColor = 'lightgrey'; // Add this line
            // 4. Insert the dialogueWrapper and textarea into the DOM, after the H1
            if (h1Element) {
                // Element.after() can insert multiple nodes
                h1Element.after(dialogueWrapper, textarea);
            } else {
                // Fallback if H1 wasn't found: prepend to the container.
                // Adjust if a different fallback is desired.
                contentContainer.prepend(dialogueWrapper, textarea);
            }
            // 5. Load from localStorage or initialize from current dialogue content
            const savedText = localStorage.getItem('platoText');
            if (savedText !== null) { // Check for null, as "" is a valid saved empty state
                // If there's saved text, render it.
                // Ensure platoTextToPlatoHtml handles empty strings gracefully (e.g., returns "").
                try {
                    dialogueWrapper.innerHTML = platoTextToPlatoHtml(savedText);
                } catch (e) {
                    console.error("Error rendering saved Plato text to HTML:", e);
                    dialogueWrapper.innerHTML = "<p>Error loading content.</p>";
                }
            } else {
                // No saved text, so use the current HTML content (if any) to populate localStorage.
                const initialDialogueHtml = dialogueWrapper.innerHTML;
                if (initialDialogueHtml.trim() !== '') {
                    try {
                        const initialPlainText = platoHtmlToPlatoText(initialDialogueHtml);
                        localStorage.setItem('platoText', initialPlainText);
                    } catch (e) {
                        console.error("Error converting initial HTML to Plato text:", e);
                        // Decide if you want to store an empty string or do something else
                        localStorage.setItem('platoText', '');
                    }
                } else {
                    // If there's no initial dialogue either, store an empty string in localStorage.
                    localStorage.setItem('platoText', '');
                }
            }
            // 6. Event listener to switch to edit mode when dialogue content is clicked
            dialogueWrapper.addEventListener('click', () => {
                try {
                    const plainText = platoHtmlToPlatoText(dialogueWrapper.innerHTML);
                    textarea.value = plainText;
                    dialogueWrapper.style.display = 'none';
                    textarea.style.display = 'block';
                    textarea.focus();
                } catch (e) {
                    console.error("Error converting HTML to Plato text for editing:", e);
                    alert("Could not switch to edit mode due to a content error.");
                }
            });
            // 7. Event listener for saving (Ctrl+Enter) in the textarea
            textarea.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault(); // Prevent default Enter behavior (like adding a new line)
                    const newText = textarea.value;
                    localStorage.setItem('platoText', newText); // Auto-save also does this, but good for explicitness
                    try {
                        dialogueWrapper.innerHTML = platoTextToPlatoHtml(newText);
                        textarea.style.display = 'none';
                        dialogueWrapper.style.display = 'block';
                    } catch (e) {
                        console.error("Error converting Plato text to HTML for display:", e);
                        alert("Could not save and display content due to a format error.");
                    }
                }
            });
            // 8. Event listener for auto-saving to localStorage on input
            textarea.addEventListener('input', () => {
                localStorage.setItem('platoText', textarea.value);
            });
        });
        </script>
    </div>
  </body>
</html>

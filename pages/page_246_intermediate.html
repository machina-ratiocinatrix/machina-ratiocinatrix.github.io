<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=b1124390a122e861b4918632b23394369790a5d0">
    <title>MACHINA RATIOCINATRIX</title>
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->
    <!-- Setup Google Analytics -->
    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->
    <!-- end custom head snippets -->
</head>
  <body>
    <div class="container-md px-3 my-5 markdown-body">
        <h1><a href="https://machina-ratiocinatrix.github.io/">Machina Ratiocinatrix</a></h1>
        <script>
            /**
 * Transforms platoHtml format to CMJ (Chat Messages JSON) format.
 * @param {string} htmlText - The platoHtml formatted string.
 * @returns {string} - JSON stringified array of message objects.
 */
            function platoHtmlToCmj(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }

              const messages = [];
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              });

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }

            /**
             * Transforms platoHtml format to platoText format.
             * @param {string} htmlText - The platoHtml formatted string.
             * @returns {string} - The platoText formatted string.
             */
            function platoHtmlToPlatoText(htmlText) {
              if (typeof htmlText !== 'string') { // Allow empty string
                throw new Error('Invalid input: htmlText must be a string');
              }
              if (!htmlText.trim()) {
                return '';
              }

              let result = '';
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return;

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();
                result += `${speaker}: ${utterance}\n\n`;
              });

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to platoHtml format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - The platoHtml formatted string.
             */
            function platoTextToPlatoHtml(platoText) {
              if (typeof platoText !== 'string') { // Allow empty string
                throw new Error('Invalid input: platoText must be a string');
              }
              // If platoText is an empty string or only whitespace, return an empty string.
              // The display logic will handle showing the file picker or placeholder.
              if (!platoText.trim()) {
                return '';
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              let result = '';
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim().replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML characters
                result += `<p class="dialogue"><span class="speaker">${speaker}</span> ${utterance}</p>\n`;
              }

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to CMJ (Chat Messages JSON) format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - JSON stringified array of message objects.
             */
            function platoTextToCmj(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              const messages = [];
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              }

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }
        </script>

        <!-- Initial dialogue content (will be moved by script) -->
        <p class="dialogue"><span class="speaker">Socrates</span>What is justice, my friend?</p>
        <!-- Commented out other examples for brevity, they would also be moved -->
        <!-- <p class="dialogue"><span class="speaker">Thrasymachus</span>Justice is the advantage of the stronger.</p> -->

        <script>
        document.addEventListener('DOMContentLoaded', () => {
            const contentContainer = document.querySelector('.container-md.markdown-body');
            if (!contentContainer) {
                console.error('Main content container (.container-md.markdown-body) not found.');
                return;
            }
            const h1Element = contentContainer.querySelector('h1');
            if (!h1Element) {
                console.error('H1 element not found. UI elements might be misplaced.');
            }

            // 1. Create a wrapper for the dialogue content
            const dialogueWrapper = document.createElement('div');
            dialogueWrapper.id = 'dialogue-content-wrapper';

            // 2. Move existing <p class="dialogue"> elements from contentContainer into dialogueWrapper
            const existingDialogues = Array.from(contentContainer.querySelectorAll('p.dialogue'));
            existingDialogues.forEach(p => {
                dialogueWrapper.appendChild(p); // This also removes them from contentContainer
            });

            // 3. Create the textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'form-control';
            textarea.style.width = '100%';
            textarea.style.minHeight = '830px';
            textarea.style.display = 'none'; // Initially hidden
            textarea.style.setProperty('border', '1px solid lightgrey', 'important');
            textarea.style.padding = '10px';

            // 4. Create container and button for file picking
            const filePickerContainer = document.createElement('div');
            filePickerContainer.id = 'file-picker-container';
            filePickerContainer.style.display = 'none'; // Initially hidden
            filePickerContainer.style.width = '100%';
            filePickerContainer.style.minHeight = '830px'; // Match textarea height
            filePickerContainer.style.display = 'flex';
            filePickerContainer.style.justifyContent = 'center';
            filePickerContainer.style.alignItems = 'center';
            filePickerContainer.style.padding = '20px';

            const chooseFileButton = document.createElement('button');
            chooseFileButton.id = 'chooseFileButton';
            chooseFileButton.className = 'btn btn-primary'; // GitHub Primer style
            chooseFileButton.textContent = 'Choose File to Load Dialogue';
            chooseFileButton.style.padding = '15px 30px'; // Make button larger
            chooseFileButton.style.fontSize = '1.25rem';
            filePickerContainer.appendChild(chooseFileButton);

            // 5. Insert elements into the DOM (after H1 or fallback)
            if (h1Element) {
                h1Element.after(dialogueWrapper, textarea, filePickerContainer);
            } else {
                contentContainer.prepend(dialogueWrapper, textarea, filePickerContainer); // Fallback
            }

            // 6. Function to update display based on localStorage content
            function updateDisplayState() {
                const currentPlatoText = localStorage.getItem('platoText');
                if (currentPlatoText && currentPlatoText.trim() !== '') {
                    try {
                        dialogueWrapper.innerHTML = platoTextToPlatoHtml(currentPlatoText);
                    } catch (e) {
                        console.error("Error rendering Plato text to HTML:", e);
                        dialogueWrapper.innerHTML = "<p class='dialogue-error'>Error loading content. Please try editing or loading a new file.</p>";
                    }
                    dialogueWrapper.style.display = 'block';
                    textarea.style.display = 'none';
                    filePickerContainer.style.display = 'none';
                } else {
                    // No valid content, show file picker
                    dialogueWrapper.style.display = 'none';
                    textarea.style.display = 'none';
                    filePickerContainer.style.display = 'flex'; // Use flex to enable centering
                    dialogueWrapper.innerHTML = ''; // Clear any old content
                    textarea.value = ''; // Clear textarea
                }
            }

            // 7. Initialize: if localStorage is null, set to empty string. Then update display.
            if (localStorage.getItem('platoText') === null) {
                localStorage.setItem('platoText', '');
            }
            updateDisplayState();

            // 8. Event listener for "Choose File" button
            chooseFileButton.addEventListener('click', async () => {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Text Files',
                            accept: {
                                'text/plain': ['.txt', '.md', '.text'],
                            }
                        }]
                    });
                    const file = await fileHandle.getFile();
                    const fileContent = await file.text();

                    localStorage.setItem('platoText', fileContent);
                    textarea.value = fileContent; // Load into textarea

                    // Switch to editor mode
                    dialogueWrapper.style.display = 'none';
                    filePickerContainer.style.display = 'none';
                    textarea.style.display = 'block';
                    textarea.focus();
                } catch (err) {
                    if (err.name !== 'AbortError') { // User cancelled picker
                        console.error('Error opening file:', err);
                        alert(`Error opening file: ${err.message}`);
                    }
                }
            });

            // 9. Event listener to switch to edit mode when dialogue content is clicked
            dialogueWrapper.addEventListener('click', () => {
                try {
                    const plainText = platoHtmlToPlatoText(dialogueWrapper.innerHTML);
                    textarea.value = plainText;
                    dialogueWrapper.style.display = 'none';
                    textarea.style.display = 'block';
                    filePickerContainer.style.display = 'none';
                    textarea.focus();
                } catch (e) {
                    console.error("Error converting HTML to Plato text for editing:", e);
                    alert("Could not switch to edit mode due to a content error.");
                }
            });

            // 10. Event listener for saving (Ctrl+Enter) in the textarea
            textarea.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault();
                    const newText = textarea.value;
                    localStorage.setItem('platoText', newText);
                    updateDisplayState(); // Update display, which will show dialogue or button
                }
            });

            // 11. Event listener for auto-saving to localStorage on input
            textarea.addEventListener('input', () => {
                localStorage.setItem('platoText', textarea.value);
            });
        });
        </script>
    </div>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=b1124390a122e861b4918632b23394369790a5d0">
    <title>MACHINA RATIOCINATRIX</title>
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->
    <!-- Setup Google Analytics -->
    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->
    <!-- end custom head snippets -->
</head>
  <body>
    <div class="container-md px-3 my-5 markdown-body">
        <h1><a href="https://machina-ratiocinatrix.github.io/">Machina Ratiocinatrix</a></h1>
        <script>
            /**
 * Transforms platoHtml format to CMJ (Chat Messages JSON) format.
 * @param {string} htmlText - The platoHtml formatted string.
 * @returns {string} - JSON stringified array of message objects.
 */
            function platoHtmlToCmj(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }

              const messages = [];
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                // Extract utterance by removing speaker span and trimming
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              });

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }

            /**
             * Transforms platoHtml format to platoText format.
             * @param {string} htmlText - The platoHtml formatted string.
             * @returns {string} - The platoText formatted string.
             */
            function platoHtmlToPlatoText(htmlText) {
              if (!htmlText || typeof htmlText !== 'string') {
                throw new Error('Invalid input: htmlText must be a non-empty string');
              }

              let result = '';
              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlText, 'text/html');
              const paragraphs = doc.querySelectorAll('p.dialogue');

              paragraphs.forEach(p => {
                const speakerSpan = p.querySelector('span.speaker');
                if (!speakerSpan) return; // Skip malformed paragraphs

                const speaker = speakerSpan.textContent.trim();
                const utterance = p.textContent.replace(speakerSpan.textContent, '').replace(/:\s*/, '').trim();
                result += `${speaker.toUpperCase()}: ${utterance}\n\n`;
              });

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to platoHtml format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - The platoHtml formatted string.
             */
            function platoTextToPlatoHtml(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              let result = '';
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim().replace(/</g, '&lt;').replace(/>/g, '&gt;'); // Escape HTML characters
                result += `<p class="dialogue"><span class="speaker">${speaker}</span>: ${utterance}</p>\n`;
              }

              return result.trimEnd();
            }

            /**
             * Transforms platoText format to CMJ (Chat Messages JSON) format.
             * @param {string} platoText - The platoText formatted string.
             * @returns {string} - JSON stringified array of message objects.
             */
            function platoTextToCmj(platoText) {
              if (!platoText || typeof platoText !== 'string') {
                throw new Error('Invalid input: platoText must be a non-empty string');
              }

              const regex = /([A-Za-z0-9_ -]+):\s*(.*?)\n\n/gs;
              const messages = [];
              let match;

              while ((match = regex.exec(platoText)) !== null) {
                const speaker = match[1].trim();
                const utterance = match[2].trim();

                let role = 'user';
                if (speaker.toUpperCase() === 'MACHINA RATIOCINATRIX') {
                  role = 'assistant';
                } else if (speaker.toUpperCase() === 'INSTRUCTIONS') {
                  role = 'system';
                }

                messages.push({
                  role: role,
                  name: speaker,
                  content: utterance
                });
              }

              try {
                return JSON.stringify(messages, null, 2);
              } catch (e) {
                throw new Error('Failed to stringify JSON: ' + e.message);
              }
            }
        </script>
        <p class="dialogue"><span class="speaker">Socrates</span>What is justice, my friend?</p>
        <p class="dialogue"><span class="speaker">Thrasymachus</span>Justice is the advantage of the stronger.</p>
        <p class="dialogue"><span class="speaker">Machina Ratiocinatrix</span>I think you are oversimplifying it, Thrasymachus, trying to reduce a truely multi-dimensional problem to a single dimension.</p>
        <p class="dialogue"><span class="speaker">Socrates</span>Can you explain what you mean, Machina?</p>
        <script>
            document.addEventListener('DOMContentLoaded', () => {
            // Get the main content container
            const contentContainer = document.querySelector('.container-md.markdown-body');
            if (!contentContainer) return;

            // Create textarea for editing
            const textarea = document.createElement('textarea');
            textarea.className = 'form-control';
            textarea.style.width = '100%';
            textarea.style.minHeight = '400px';
            textarea.style.display = 'none';

            // Insert textarea after content container
            contentContainer.parentNode.insertBefore(textarea, contentContainer.nextSibling);

            // Load from localStorage if available
            const savedText = localStorage.getItem('platoText');
            if (savedText) {
                contentContainer.innerHTML = platoTextToPlatoHtml(savedText);
            }

            // Toggle to editor mode on click
            contentContainer.addEventListener('click', () => {
                const plainText = platoHtmlToPlatoText(contentContainer.innerHTML);
                textarea.value = plainText;
                contentContainer.style.display = 'none';
                textarea.style.display = 'block';
                textarea.focus();
            });

            // Handle Ctrl+Enter to save and render
            textarea.addEventListener('keydown', (event) => {
                if (event.ctrlKey && event.key === 'Enter') {
                    const newText = textarea.value;
                    localStorage.setItem('platoText', newText);
                    contentContainer.innerHTML = platoTextToPlatoHtml(newText);
                    textarea.style.display = 'none';
                    contentContainer.style.display = 'block';
                }
            });

            // Auto-save to localStorage on input
            textarea.addEventListener('input', () => {
                localStorage.setItem('platoText', textarea.value);
                });
            });
        </script>
    </div>
  </body>
</html>
